name: Build with MY ROM

on:
  push:
    branches: [ "main", "master" ]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-my-rom:
    runs-on: ubuntu-latest

    steps:
    - name: üì• Checkout do C√≥digo
      uses: actions/checkout@v4

    - name: ‚òï Configurar Java 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: üéÆ Configurar a Sua ROM
      run: |
        mkdir -p app/src/main/assets
        
        # 1. Procura sua ROM (.smc, .sfc ou .gb) na raiz do reposit√≥rio
        echo "Procurando ROMs na raiz..."
        MY_ROM=$(find . -maxdepth 1 -type f \( -name "*.smc" -o -name "*.sfc" -o -name "*.gb" \) | head -n 1)
        
        if [ -n "$MY_ROM" ]; then
          echo "‚úÖ ROM encontrada: $MY_ROM"
          cp "$MY_ROM" app/src/main/assets/game.bin
        else
          echo "‚ö†Ô∏è Nenhuma ROM encontrada. Baixando Demo..."
          wget -O app/src/main/assets/game.bin "https://github.com/PeterLemon/SNES/raw/master/Demo/Hello/Hello.snes"
        fi

    - name: üõ†Ô∏è Aplicar Corre√ß√µes de C√≥digo (Android Port)
      run: |
        # 1. MEMORY.JAVA (Carregar Bytes Gen√©ricos)
        cat <<EOF > app/src/main/java/snes/Memory.java
        package snes;
        public class Memory {
            public byte[] physicalMemory;
            public boolean HiROM = true;
            public String name = "Loaded ROM";
            public SNES snes;
            public Memory(SNES snes) {
                this.snes = snes;
                physicalMemory = new byte[0x1000000];
                for (int i=0x7e0000; i<0x7fffff; i++) physicalMemory[i]=0x55;
            }
            public void loadRomBytes(byte[] rawdata) {
                // Tenta carregar no endere√ßo padr√£o de HiROM (C00000)
                int cartridgeOffset = rawdata.length % 0x1000;
                try {
                    for(int address=0xc00000; address<=0xffffff; address++) {
                        int index = address - 0xc00000 + cartridgeOffset;
                        if (index < rawdata.length) physicalMemory[address] = rawdata[index];
                    }
                    // Configura vetores de reset
                    if(rawdata.length > 4) {
                        physicalMemory[0xfffc] = rawdata[rawdata.length - 4];
                        physicalMemory[0xfffd] = rawdata[rawdata.length - 3];
                    }
                } catch(Exception e) { e.printStackTrace(); }
            }
            public byte readByte(int address) {
                if (address >= 0 && address < physicalMemory.length) return physicalMemory[address];
                return 0;
            }
            public void writeByte(int address, byte value) {
                if (address >= 0 && address < physicalMemory.length) physicalMemory[address] = value;
            }
            // Mocks
            public void loadCartridge(Object c) {}
            public void loadMemoryState(String s) {}
            public String dumpMemoryState() { return ""; }
        }
        EOF

        # 2. SNES.JAVA (L√≥gica Principal)
        cat <<EOF > app/src/main/java/snes/SNES.java
        package snes;
        import com.javasnes.EmulatorView;
        import java.util.ArrayList;
        public class SNES {
            public Memory memory; public Processor65816 processor; public PPU ppu; public DMA[] dma = new DMA[8];
            public Video video; public Screen screen; public SPC700 spc700; public DSP dsp;
            public Gameboy gameboy; public NES nes; public Romhack romhack;
            public boolean dogameboy = false; public boolean dones = false; public boolean doromhack = false;
            public String gamename = "game.bin"; public String sramname = "";
            public boolean cycleAccurate = false; public boolean IRQEnabled = false; public boolean multithreaded = false;
            public boolean apuEnabled = true; public boolean ischrono = false; public boolean debugMode = false;
            public boolean mute = false; public boolean recalculateIPS = true;
            public int FRAME_SKIP = 1; public int APU_INSTRUCTIONS_PER_CPU_INSTRUCTION = 3; public int CYCLES_PER_INSTRUCTION = 20;
            public static final int CYCLES_UNTIL_HDMA_START=1106, CYCLES_UNTIL_HCOUNTER=1364, CYCLES_UNTIL_HDMA_INIT=20, CYCLES_UNTIL_RENDER=192, CYCLES_UNTIL_WRAM_REFRESH=538, CYCLES_UNTIL_HBLANK=1096;
            public static final int WRAM_REFRESH_CYCLES=40;
            public long frameCount = 0; 
            public double INSTRUCTIONS_PER_SECOND = 3000000; public boolean interruptPending = false; public boolean IRQLine = false;
            public double MAX_FPS = 60.0; public boolean singlestepframe = false;
            public long eventCycles = 0, lastEventCycles = 0;
            public int instructionsSinceHCOUNTER = 0; public int nextEvent = 0; public int savestateversion = 0;
            
            public EmulatorView androidView;
            public SNESGUI snesgui; public SNESApplet applet; public Lock pauselock; 

            public SNES(EmulatorView view) {
                this.androidView = view;
                this.snesgui = new SNESGUI(); 
                this.pauselock = new Lock();
                constructSNES();
            }
            public void constructSNES() {
                processor = new Processor65816(this); memory = new Memory(this); spc700 = new SPC700(this);
                dsp = new DSP(this); ppu = new PPU(this); video = new Video(this); screen = new Screen(this);
                gameboy = new Gameboy(this); nes = new NES(this); romhack = new Romhack(this, new byte[0], 0, 0);
                for(int i=0; i<8; i++) dma[i] = new DMA(this, i);
            }
            
            public void loadRom(byte[] romData) {
                memory.loadRomBytes(romData);
                initializeSNES();
            }

            public void initializeSNES() { processor.reset(); spc700.reset(); ppu.ppureset(); }
            
            public void mainLoop() {
                long frametime = System.currentTimeMillis();
                while (true) {
                    if(!processor.waitForInterrupt) processor.doAnInstruction();
                    ppu.VCounter++; // Loop simplificado para evitar travamento
                    if(ppu.VCounter > 262) { 
                        ppu.VCounter = 0; 
                        if(!skipframe) ppu.endScreenRefresh();
                        long curr = System.currentTimeMillis();
                        if(curr - frametime < 16) { try { Thread.sleep(16 - (curr - frametime)); } catch(Exception e){} }
                        frametime = curr;
                    }
                }
            }
            // Mocks
            public void docycles(int i) {}
            public void saveSRAM() {}
            public void dumpStateToFile(String f) {}
            public void loadStateFromFile(String f) {}
            public void handleEvent() {}

            public class SNESGUI {
                public ButtonComponent buttonComponent = new ButtonComponent();
                public Trace cputrace = new Trace();
                public Trace spc700trace = new Trace();
                public void statusUpdate() {}
                public void settext(String t) {}
                public class Trace { public void printf(String s, Object... args) {} }
                public class ButtonComponent { 
                    public Button step = new Button(); public Button pause = new Button();
                    public class Button { public void setEnabled(boolean b){} public void setText(String s){} }
                }
            }
            public class SNESApplet {}
            public class Lock {
                public void testlock() {} public void lock() {} public void unlock() {} public void sleepUntilLocked() {} public boolean islocked() { return false; }
            }
        }
        EOF

        # 3. MAINACTIVITY.JAVA (Carregar Asset 'game.bin')
        cat <<EOF > app/src/main/java/com/javasnes/MainActivity.java
        package com.javasnes;
        import android.app.Activity;
        import android.os.Bundle;
        import snes.SNES;
        import java.io.InputStream;
        import java.io.IOException;

        public class MainActivity extends Activity {
            private SNES snes;
            private EmulatorView emulatorView;

            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                emulatorView = new EmulatorView(this);
                setContentView(emulatorView);

                new Thread(() -> {
                    snes = new SNES(emulatorView);
                    try {
                        // L√™ o arquivo gen√©rico 'game.bin' que foi copiado no passo anterior
                        InputStream is = getAssets().open("game.bin");
                        byte[] romData = new byte[is.available()];
                        is.read(romData);
                        is.close();
                        snes.loadRom(romData);
                        snes.mainLoop();
                    } catch (IOException e) { e.printStackTrace(); }
                }).start();
            }
        }
        EOF

        # 4. Outras Classes de Apoio (Video, Romhack)
        cat <<EOF > app/src/main/java/snes/Video.java
        package snes;
        public class Video {
            public int[][] screen; SNES snes; BGMap[] bg; public boolean spritesOn; public boolean windowsEnabled; public RenderThread renderThread;
            public Video(SNES snes) {
                this.snes=snes; screen=new int[256][224]; bg=new BGMap[5];
                bg[1]=new BGMap(1); bg[2]=new BGMap(2); bg[3]=new BGMap(3); bg[4]=new BGMap(4);
                renderThread = new RenderThread(); spritesOn=true; windowsEnabled=true;
            }
            public void updateWholeScreen() {} public void startScreenRefresh() {}
            public void endScreenRefresh() { snes.screen.repaint(); }
            public void updateLines(int scanline) {} public void updateMode() {} public void drawBGs() {}
            public class BGMap { public boolean toggledOn=true; public BGMap(int i) {} public void updateMode() {} public int[][] getAllPixels() { return new int[0][0]; } }
            public class RenderThread { public void endRefresh() {} public void startRefresh() {} public void render(int l) {} }
        }
        EOF

        cat <<EOF > app/src/main/java/snes/Romhack.java
        package snes;
        public class Romhack {
            public Romhack(SNES s, byte[] b, int i, int o) {}
            public void instructionInfo(String s, boolean b, boolean b2, int i) {}
            public void onfetch(int a, int v) {}
            public void firstInstructionByte() {}
            public void dumpKnownROM() {}
        }
        EOF

    - name: üíæ Commitar e Atualizar Reposit√≥rio
      run: |
        git config --global user.name 'GitHub Actions'
        git config --global user.email 'actions@github.com'
        git add .
        git diff --staged --quiet || git commit -m "Update: Configure ROM and fix classes"
        git push

    - name: ‚öôÔ∏è Configurar Gradle
      run: |
        gradle wrapper --gradle-version 8.2 --distribution-type bin
        chmod +x gradlew

    - name: üî® Compilar APK (Debug)
      run: ./gradlew assembleDebug --stacktrace

    - name: üì§ Upload do APK
      uses: actions/upload-artifact@v4
      with:
        name: snes-android-game
        path: app/build/outputs/apk/debug/app-debug.apk
